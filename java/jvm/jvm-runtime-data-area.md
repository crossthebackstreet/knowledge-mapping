#### JVM Runtime Data Area - JVM运行时数据区
Java虚拟机规范将JVM运行时管理的内存区域划分成了若干个数据区域
![JVM运行时数据区]

**1. Progress Counter Register - PC 寄存器**
Java中线程是通过线程轮流调度获取CPU执行时间的，因此在某一个具体的时间一个CPU只能执行一个线程中的指令。为了线程切换后能够恢复到正确的位置，每个线程都需要有一个独立的PC寄存器，每个线程间的PC寄存器互不影响。PC寄存器是线程私有的。

PC寄存器也可以称为程序计数器，可以看作是当前线程执行字节码指令的行号指示器，字节码解释器就是通过这个计数器的值来选取下一条要执行的字节码指令，分支、跳转、循环、异常等功能都需要计数器来完成。

如果当前线程正在执行一个Java方法，那么这个计数器记录的就是正在执行的字节码指令的地址；如果当前线程正在执行一个Native方法，那么这个计数器记录的值为undefined。

PC寄存器的容量至少应当能保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。

**2. VM Stack - 虚拟机栈**
Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型，它里面存放的是栈帧(Stack Frame)，栈帧里保存了局部变量表、操作数栈、动态链接、方法出口等信息。Java方法的调用过程对应着栈帧的入栈和出栈过程，方法执行时创建栈帧并入栈，方法结束时栈帧出栈。位于栈顶的栈帧称为当前栈帧，与之关联的Java方法称为当前方法。对于执行引擎，活动线程中只有当前栈帧是有效的，执行引擎所运行的所有字节码指令都只针对当前栈帧执行。源码编译时栈帧中的局部变量表大小、栈帧深度都已经确定，并且写入方法表的Code属性中。因此，一个栈帧需要分配多少内存，不会受程序运行期变量的影响，仅仅取决于具体的虚拟机表现。Java虚拟机栈所使用的内存不需要保证物理连续。

Java虚拟机中对于此区域定义了两种异常情况：
* *StackOverflowError*：如果线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError
* *OutOfMemoryError*：如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError

这两种异常情况存在一些重叠：当栈空间无法继续分配时，难以判断是内存空间太大还是栈空间太大。在单线程中，无论哪种情况都只会抛出StackOverflowError。在多线程中只会抛出OutOfMemoryError。

**3. Native Method Stack - 本地方法栈**
本地方法栈与虚拟机栈发挥的作用非常相似，它们之间的区别是虚拟机栈为Java方法服务，而本地方法栈为Native方法服务。在Sun HotSpot虚拟机中，虚拟机栈和本地方法栈是一个。

**4. Heap - 堆**
Java堆是JVM管理的内存中最大的一块，它是所有线程共享的内存区域。Java堆在虚拟机启动的时候就被创建，是垃圾收集器（garbage collector）所管理的主要区域，因此有时也称为GC堆（Garbage Collected Heap）。所有的对象实例和数组都在这里分配内存。

Java堆的容量可以是固定的（通过修改虚拟机参数实现，将堆的最小值-Xms参数与堆的最大值-Xmx参数设置一样即可避免堆自动扩展），也可以随着程序执行而动态扩展。Java堆在物理内存空间上可以不连续，只要在逻辑上连续即可。

Java堆可能发生的异常情况：
* 如果堆超过了自动内存管理系统所提供的最大容量，那么Java虚拟机将抛出OutOfMemoryError异常信息。

**5. Method Area - 方法区**
方法区是线程共享的内存区域。它存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Java虚拟机规范将方法区描述为堆的一个逻辑部分。在Sun HotSpot虚拟机中方法区又称为”永久代“。它和堆一样不需要连续的空间，可以设定为固定大小或可扩展。虚拟机规范规定这块区域可以选择不实现垃圾回收。

**6. Runtime Constant Pool - 运行时常量池**


[JVM运行时数据区]: <../../_assets/JVM-runtime-data-area.png>