#### 垃圾收集
GC需要完成三件事情，
1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？

##### 1. 哪些内存需要回收？
JVM运行时数据区中，PC寄存器、虚拟机栈、本地方法栈是线程私有的内存区域，生命周期与线程相同。堆、方法区是线程共享的内存区域，也是内存回收的主要区域。在堆中，会回收那些不再需要的对象，在方法区中，会回收废弃常量和无用的类。

判定一个对象是否还有用，需要通过**对象存活判定算法**实现。对象存活判定算法主要有两种：**引用计数算法**和**可达性分析算法**。引用计数算法的实现是，为每一个对象添加一个引用计数器，每当有一个地方引用它，计数器的值就加一，如果引用失效，计数器的值减一，任何时刻计数器值为0的对象不会再使用。引用计数算法的优点是实现简单，判定效率高，缺点是无法解决对象相互引用的问题。可达性分析算法的实现是，以一系列称作**GC Roots**的对象作为起点，向下搜索，搜索所走过的路径称为引用链(Reference Chain)，如果一个对象不在任何一条引用链上，则证明此对象是不可用的。可以作为GC Roots的对象有:
- 局部变量表中引用的对象
- 方法区中静态变量引用的对象
- 方法区中常量引用的对象
- Native方法中引用的对象
  
Java中使用可达性分析算法判定对象存活。

Java中有四种引用，强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)，引用强度依次减弱。
- 强引用指通过new关键字创建的引用，只要强引用在，垃圾收集器就不会回收被引用的对象
- 软引用描述一些有用但非必需的对象，在内存溢出之前，垃圾收集器会回收这些对象，通过SoftReference实现软引用
- 弱引用也用来描述一些有用但非必需的对象，在下一次垃圾收集时，无论内存是否足够，都会被回收，通过WeakReference实现弱引用
- 虚引用也称作幽灵引用或幻影引用，一个对象是否有虚引用的存在，完全不会对其产生影响，也无法通过虚引用取得一个对象的实例，使用虚引用的唯一目的是能在对象被垃圾收集器回收前收到一个系统通知，通过PhantomReference实现虚引用。

要回收一个对象，至少要经历两次标记，通过对象存活判定算法判定对象不可用时，会进行第一次标记并进行一次筛选，筛选的条件是对象是否有必要执行finalize()，如果对象没有覆盖fianlize()或者finalize()已经执行过一次，则判定没有必要执行finalize()。如果对象有必要执行finalize()，那么这个对象会被放置在一个称作F-Queue的队列中，等待由JVM自动创建的、低优先级的线程Finalizer去执行，但是并不能等待finalize()执行结束。finalize()是对象逃脱被回收的最后机会，只要对象与引用链上的任何一个对象建立关联即可，在第二次标记时会被移除出F-Queue。fianlize()运行代价高，不确定性大，无法保证各个对象的调用顺序，不用当作C++中的析构函数使用。