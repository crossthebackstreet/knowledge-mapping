#### 自动内存管理机制
Java自动内存管理是为了解决两个问题：内存分配和内存回收。

#### 垃圾收集
垃圾收集(Garbage Collection, GC)经过长期的发展，最终都需要完成三件事情，
1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？

##### 哪些内存需要回收
JVM运行时数据区中，PC寄存器、虚拟机栈、本地方法栈是线程私有的内存区域，生命周期与线程相同。堆、方法区是线程共享的内存区域，也是内存回收的主要区域。在堆中，会回收那些不再需要的对象，在方法区中，会回收废弃常量和无用的类。

判定一个对象是否还有用，需要通过**对象存活判定算法**实现。对象存活判定算法主要有两种：**引用计数算法**和**可达性分析算法**。引用计数算法的实现是，为每一个对象添加一个引用计数器，每当有一个地方引用它，计数器的值就加一，如果引用失效，计数器的值减一，任何时刻计数器值为0的对象不会再使用。引用计数算法的优点是实现简单，判定效率高，缺点是无法解决对象相互引用的问题。可达性分析算法的实现是，以一系列称作**GC Roots**的对象作为起点，向下搜索，搜索所走过的路径称为引用链(Reference Chain)，如果一个对象不在任何一条引用链上，则证明此对象是不可用的。可以作为GC Roots的对象有:
- 局部变量表中引用的对象
- 方法区中静态变量引用的对象
- 方法区中常量引用的对象
- Native方法中引用的对象

Java中使用可达性分析算法判定对象存活。

方法区回收废弃常量与回收Java对象非常类似，如果一个废弃常量不再被使用，将会被回收，包含常量池中类、接口、方法、字段的符号引用，字面量等。要判定一个类是否是无用的类，必须同时满足三个条件：
- 该类所有的对象实例都已经被回收
- 加载该类的类加载器已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法

Hotspot虚拟机可以通过设置-Xnoclassgc来避免类的回收。

##### 什么时候回收
内存不足时就会发生回收。

Java中有四种引用，强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)，引用强度依次减弱。
- 强引用指通过new关键字创建的引用，只要强引用在，垃圾收集器就不会回收被引用的对象
- 软引用描述一些有用但非必需的对象，在内存溢出之前，垃圾收集器会回收这些对象，通过SoftReference实现软引用
- 弱引用也用来描述一些有用但非必需的对象，在下一次垃圾收集时，无论内存是否足够，都会被回收，通过WeakReference实现弱引用
- 虚引用也称作幽灵引用或幻影引用，一个对象是否有虚引用的存在，完全不会对其产生影响，也无法通过虚引用取得一个对象的实例，使用虚引用的唯一目的是能在对象被垃圾收集器回收前收到一个系统通知，通过PhantomReference实现虚引用。

##### 如何回收
要回收一个对象，至少要经历两次标记，通过对象存活判定算法判定对象不可用时，会进行第一次标记并进行一次筛选，筛选的条件是对象是否有必要执行finalize()，如果对象没有覆盖fianlize()或者finalize()已经执行过一次，则判定没有必要执行finalize()。如果对象有必要执行finalize()，那么这个对象会被放置在一个称作F-Queue的队列中，等待由JVM自动创建的、低优先级的线程Finalizer去执行，但是并不能等待finalize()执行结束。finalize()是对象逃脱被回收的最后机会，只要对象与引用链上的任何一个对象建立关联即可，在第二次标记时会被移除出F-Queue。fianlize()运行代价高，不确定性大，无法保证各个对象的调用顺序，不用当作C++中的析构函数使用。

垃圾收集由垃圾收集器执行。
几种垃圾收集算法:
1. 标记-清除算法\
   算法分为标记和清除两个阶段，首先标记需要被回收的对象，标记完成后进行统一回收。这种算法有两种不足，一是效率问题，标记和清除的效率都不高，二是空间问题，垃圾收集之后会产生大量不连续的空间，这样会导致分配大对象时由于内存空间不足而不得不提前触发垃圾收集。
2. 复制算法\
   将内存空间分为大小相等的两块，每次只使用其中的一块，当这块内存空间不足时，会将存活的对象复制到另外一块内存上，再将使用过的内存清理。这种算法实现简单、高效，可以解决内存碎片问题，但是每次只使用一半内存，会有些浪费。虚拟机的实现方式是将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次只使用Eden和一块Survivor，回收时将存活的对象复制到另一块Survivor上，清除Eden和使用的Survivor。Hotspot默认Eden与Survivor的比例是8:1。当Survivor空间不足时，需要依赖其他内存（老年代）来进行分配担保。
3. 标记-整理算法\
   标记-整理算法的标记过程与标记-清除算法的一样，之后让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。
4. 分代算法\
   分代算法是根据对象存活周期的不同将内存划分为几块。一般把堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。**新生代采用复制算法，老年代采用标记-整理算法或者标记-清除算法。**

Stop The World：GC进行时必须停顿所有Java执行线程。虚拟机有办法得知哪些地方存放着对象引用，在Hotspot中，是使用一组称为OopsMap的数据结构来存储，在OopsMap的协助下，Hotspot可以快速准确的完成GC Roots枚举。

Minor GC、Major GC、Full GC的区别(参考[知乎问题](https://www.zhihu.com/question/41922036))\
Minor GC发生在新生代，出现非常频繁，回收速度快\
Major GC发生在老年代，出现Major GC通常至少触发一次Minor GC\
Full GC是针对新生代、老年代、元空间(永久代)的全局范围GC

#### 垃圾收集器
![垃圾收集器]

#### 内存分配策略
1. 对象优先在Eden分配
2. 长期存活的对象将进入老年代
3. 大对象直接进入老年代
4. 动态对象年龄判断
5. 空间分配担保


[垃圾收集器]: <../../_assets/garbage-collectors.png>
